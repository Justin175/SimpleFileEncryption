package sfe.commands;

import static sfe.SimpleFileEncryption.printCommandInfo;
import static sfe.SimpleFileEncryption.setErrorString;

import java.awt.Desktop;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.LinkedList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import javax.crypto.NoSuchPaddingException;

import sfe.AESCrypter;
import sfe.Crypter;
import sfe.command.ConsoleCommand;
import sfe.io.CryptedInputStream;
import sfe.io.CryptedOutputStream;
import sfe.utils.CryptingRunnable;
import sfe.utils.FlagProcessor;

public class CommandDecrypt extends ConsoleCommand {

	private static CommandDecrypt commandEncrypt;
	
	public static final String[] ALLOWED_FLAGS = {
			"--help",
			"-p [Password]",
			"-f [File]",
			"-o [Out-Name]",
			"-h",
			"-u",
			"-d",
			"-r",
			"-z",
			"-zc",
			"-s"
	};
	
	public static final String[] FLAGS_DESCRYPTION = {
		/**/	"Prints Command-Help-Information",
		/*p */	"Password given as plain-text",
		/*f */	"Password stored in a file",
		/*o */	"Define the name/path of the output-file <Use * in name/path for adding autogenerated and checked number>",
		/*h */	"Password is hashed",
		/*u */	"Path is a URL",
		/*d */	"Path is a directory",
		/*r */	"Recursive-Mode (process main directories and sub-directories",
		/*z */	"Ouput files as zip",
		/*zc*/	"Decrypts the content of a Zip-File <Flag -z is automaticly included>",
		/*s */	"Opens the parent directory of the output-file"
	};

	public CommandDecrypt() {
		super("decrypt", "de", CommandDecrypt::process, "decrypt  [<flags>...] [path]");
		
		commandEncrypt = this;
	}
	
	private static boolean process(String[] args) {
		//--help-Flag is processed lonely
		if(args[0].equalsIgnoreCase("--help")) {
			printCommandInfo(commandEncrypt, ALLOWED_FLAGS, FLAGS_DESCRYPTION);
			return true;
		}
		
		if(args.length < 3) {
			setErrorString("Wrong number of Arguments!", "Expected: > 2, Given: " + args.length);
			return false;
		}
		
		FlagProcessor fp = createFlagProcessor();
		fp.process(args, 0, args.length - 1);
		
		//check flags
		if(!fp.containsFlagData("password_text") && !fp.containsFlagData("password_file")) {
			setErrorString("Missing Flags.", "The flags -p or -f not given.", "Expected: 1", "Given: 0");
			return false;
		}
		
		if(fp.containsFlagData("password_text") && fp.containsFlagData("password_file")) {
			setErrorString("To many flags.", "The flags -p and -f are given at the same time.", "Expected: 1", "Given: 2");
			return false;
		}
		
		//process-Flags
		boolean isHashed = false;
		boolean isDirectory = false;
		boolean isRecursive = false;
		boolean isURL = false;
		boolean isZipOutput = false;
		boolean isOpenAfterEncryption = false;
		boolean isZipInput = false;
		File output;
		
		if(fp.containsFlagData("hashed"))
			isHashed = true;
		
		if(fp.containsFlagData("directory"))
			isDirectory = true;
		
		if(fp.containsFlagData("recursive"))
			isRecursive = true;
		
		if(fp.containsFlagData("zip"))
			isZipOutput = true;
		
		if(fp.containsFlagData("show_after_processing"))
			isOpenAfterEncryption = true;
		
		if(fp.containsFlagData("zip_input"))
			isZipInput = true;
		
		if(fp.containsFlagData("url"))
			isURL = true;
		
		if(isURL && isDirectory) {
			setErrorString("The Flags -d and -u cannot be used at the same time.");
			return false;
		}
		
		//check to decryt file for existence
		File toDecrypt;
		if(isURL) {
			try {
				toDecrypt = new File(new URL(args[args.length - 1]).toURI());
			} catch (MalformedURLException | URISyntaxException e) {
				setErrorString("Failed to create tranform the link into a URL", "Java-Error-Message: " + e.getMessage());
				return false;
			}
		} 
		else { 
			toDecrypt = new File(args[args.length - 1]);
		}
		
		if(!toDecrypt.exists()) {
			setErrorString("The target-file/directory for decryption not exists.", "Given: " + args[args.length - 1]);
			return false;
		}
		
		//check target-file
		if(isDirectory && !toDecrypt.isDirectory()) {
			setErrorString("Given Path is not a directory.", "Given: " + args[args.length - 1]);
			return false;
		}
		
		if(isZipInput && isDirectory) {
			setErrorString("The Flags -zc and -d can not be used together.");
			return false;
		}
		
		//check out_name flag
		if(fp.containsFlagData("out_name")) {
			String name = (String) fp.getData("out_name");
			if(name.contains("*")) {
				//count
				int count = 0;
				for(char a : name.toCharArray())
					if(a == '*') count++;
				
				if(count > 1) {
					setErrorString("Only 1 '*' is allowed.", "Expected: 1", "Given: " + count);
					return false;
				}
				
				int currentNumber = 0;
				output = new File(name.replace("*", "")); 
				
				while(output.exists() && (isDirectory ? output.isDirectory() : output.isFile()))
					output = new File(name.replace("*", "" + (currentNumber++)));
			}
			else
				output = new File(name);
			
			if(output.exists() && ((isDirectory && !isZipOutput) ? output.isDirectory() : output.isFile())) {
				setErrorString(
						"The choosen Output-Name already existing in this directory.",
						"Given: " + name,
						"Given <Absulute-Path>: " + output.getAbsolutePath(),
						"Given <Sub-Directory>:" + output.getAbsoluteFile().getParent()
				);
						
				return false;
			}
		}
		else { //generate output-file
			if(isURL) {
				setErrorString("When using -u, the flag -o <name> must be used");
				return false;
			}
			
			String name = toDecrypt.getName() + (isZipOutput ? ".zip" : ".en");
			output = new File(name);
			
			if(output.exists() && ((isDirectory && !isZipOutput) ? output.isDirectory() : output.isFile())) {
				int i = toDecrypt.getName().indexOf('.');
				String firstHalf = i != -1 ? toDecrypt.getName().substring(0, i) : toDecrypt.getName();
				int currentNumber = 0;
				String end = (i != -1 ? toDecrypt.getName().substring(i) : "") + (isZipOutput ? ".zip" : ".en");
				
				while(output.exists() && ((isDirectory && !isZipOutput) ? output.isDirectory() : output.isFile()))
					output = new File(firstHalf + (currentNumber++) + end);
			}
		}
		
		//read-password
		byte[] password = readPassword((String) fp.getData("password"), fp.containsFlagData("password_file"));
		if(password == null)
			return false;
		
		//start decrypting
		try {
			AESCrypter crypter = new AESCrypter(Crypter.MODE_DECRYPT, password, isHashed);
			
			if(isDirectory)
				decryptDirectory(crypter, toDecrypt, output, isRecursive, isZipOutput);
			else if(isZipInput)
				decryptZipFile(crypter, toDecrypt, output);
			else
				decryptFile(crypter, toDecrypt, output, isZipOutput);
		} catch (IOException e) {
			e.printStackTrace();
			setErrorString("An error corrupted while writing the decrypted-file/directory.", "Java-Error-Message: " + e.getMessage());
			return false;
		} catch (InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException e) {
			setErrorString("An error corrupted while decrypting.", "Java-Error-Message: " + e.getMessage());
			return false;
		}
		
		if(isOpenAfterEncryption) {
			try {
				Desktop.getDesktop().open(output.getAbsoluteFile().getParentFile());
			} catch (IOException e) {
				System.err.println("Unable to open the output-file directory.");
				System.err.println("Error-Message: " + e.getMessage());
			}
		}
		
		return true;
	}
	
	private static void decryptZipFile(AESCrypter crypter, File toDecrypt, File output) throws IOException {
		//start decrypt
		decrypt(output, () -> {
			//create is
			ZipInputStream zis = new ZipInputStream(new FileInputStream(toDecrypt));
			CryptedInputStream cis = new CryptedInputStream(zis, crypter);
			
			//create os
			ZipOutputStream os = new ZipOutputStream(new FileOutputStream(output));
			
			//start decrypt
			ZipEntry current;
			
			while((current = zis.getNextEntry()) != null) {
				//Set entry
				os.putNextEntry(new ZipEntry(current.getName()));
				
				//start reading
				int b;
				while((b = cis.read()) != -1)
					os.write(b);
			}
			
			//close streams
			cis.close();
			os.close();
		});
	}

	private static void decryptFile(Crypter crypter, File toDecrypt, File output, boolean isZipOutput) throws IOException {
		OutputStream os;
		
		if(isZipOutput) {
			ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(output));
			os = new CryptedOutputStream(zos, crypter);
			zos.putNextEntry(new ZipEntry(toDecrypt.getName()));
		}
		else {
			os = new FileOutputStream(output);
		}
		
		decrypt(output, () -> readAndWrite(os, new CryptedInputStream(new FileInputStream(toDecrypt), crypter)));
		os.close();
	}
	
	private static void decryptDirectory(Crypter crypter, File toDecrypt, File output, boolean isRecursive, boolean isZipOutput) throws IOException {
		List<File> files = new LinkedList<>();
		System.out.println("Loading Files...");
		getFiles(toDecrypt, files, isRecursive);
		
		int encryptionLength = toDecrypt.getAbsoluteFile().getAbsolutePath().length() + 1;
		
		if(isZipOutput) {
			//Adding later
		}
		else
			decryptDirectoryToDirectory(crypter, toDecrypt, output, files, encryptionLength);
	}
	
	private static void decryptDirectoryToDirectory(Crypter crypter, File toDecrypt, File output, List<File> files, int encryptionLength) throws IOException {
		String outputPath = output.getAbsolutePath() + "/";
		
		decrypt(output, () -> {
			String out;
			File outFile = new File(outputPath);
			outFile.mkdirs();
			
			for(File a : files) {
				out = a.getAbsolutePath().substring(encryptionLength);
				outFile = new File(outputPath + out);
				
				FileOutputStream os = new FileOutputStream(outFile);
				InputStream is = new CryptedInputStream(new FileInputStream(a), crypter);
				
				readAndWrite(os, is);
				
				is.close();
				os.close();
			}
		});
	}
	
	private static void getFiles(File currentDir, List<File> files, boolean recursive) {
		for(File a : currentDir.listFiles()) {
			if(a.isFile())
				files.add(a);
			
			if(recursive && a.isDirectory())
				getFiles(a, files, recursive);
		}
	}
	
	private static void decrypt(File output, CryptingRunnable run) throws IOException {
		System.out.println("Start decryption....");
		long time = System.currentTimeMillis();
		run.run();
		time = System.currentTimeMillis() - time;
		System.out.println("End decryption...");
		
		printEncryptionInfo(output, time);
	}
	
	private static void printEncryptionInfo(File output, long time) {
		System.out.println("Decryption end.");
		System.out.println("Output-Info:");
		System.out.println("  Path <Relative>:  " + output.getPath());
		System.out.println("  Path <Absolute>:  " + output.getAbsolutePath());
		System.out.println("  Name:             " + output.getName());
		System.out.println("  Time took:        " + (time < 1000 ? time + " ms" : (time / 1000) + " s"));
	}
	
	private static void readAndWrite(OutputStream os, InputStream is) throws IOException {
		int b = is.read();
		while(b != -1) {
			os.write(b);
			b = is.read();
		}
	}
	
	private static byte[] readPassword(String pwLink, boolean isFile) {
		if(!isFile)
			return pwLink.getBytes(StandardCharsets.UTF_8);
		
		//read file
		File pwFile = new File(pwLink);
		
		//check file
		if(!pwFile.exists() || !pwFile.isFile()) {
			setErrorString("Password-File not found.", "Given: " + pwLink);
			return null;
		}
		
		//check file-size
		if(pwFile.length() > (1024 * 1024 * 20)) /*20mbytes*/ {
			int mb = 1024 * 1024;
			setErrorString("Password-File is to big.", "Expected: 20 Mbytes", "Given: round > " + (pwFile.length() / mb) + "mb");
			return null;
		}
		
		//Read File
		byte[] password = new byte[(int) pwFile.length()];
		
		try {
			FileInputStream is = new FileInputStream(pwFile);
			int index = 0;
			
			while(index != password.length)
				password[index++] = (byte) is.read(); 
			
			is.close();
		} catch (Exception e) {
			setErrorString("An error corrupted while reading the password-file.", "Given: " + pwLink);
		}
		
		return password;
	}
	
	@SuppressWarnings("unchecked")
	private static final FlagProcessor createFlagProcessor() {
		FlagProcessor fp = new FlagProcessor();
		fp.setFlagsPredicate(
				"-p"::equalsIgnoreCase,
				"-f"::equalsIgnoreCase,
				"-o"::equalsIgnoreCase,
				"-h"::equalsIgnoreCase,
				"-u"::equalsIgnoreCase,
				"-d"::equalsIgnoreCase,
				"-r"::equalsIgnoreCase,
				"-z"::equalsIgnoreCase,
				"-zc"::equalsIgnoreCase,
				"-s"::equalsIgnoreCase
		);
		fp.setFlagProcess(
				/*-p  */ (flag, arguments, index, flagsData) -> { flagsData.put("password_text", true); flagsData.put("password", arguments.length > (index + 1) ? arguments[index + 1] : null); },
				/*-f  */ (flag, arguments, index, flagsData) -> { flagsData.put("password_file", true); flagsData.put("password", arguments.length > (index + 1) ? arguments[index + 1] : null); },
				/*-o  */ (flag, arguments, index, flagsData) -> { flagsData.put("out_name", arguments.length > (index + 1) ? arguments[index + 1] : null); },
				/*-h  */ (flag, arguments, index, flagsData) -> { flagsData.put("hashed", true); },
				/*-u  */ (flag, arguments, index, flagsData) -> { flagsData.put("url", true); },
				/*-d  */ (flag, arguments, index, flagsData) -> { flagsData.put("directory", true); },
				/*-r  */ (flag, arguments, index, flagsData) -> { flagsData.put("recursive", true); },
				/*-z  */ (flag, arguments, index, flagsData) -> { flagsData.put("zip", true); },
				/*-zc */ (flag, arguments, index, flagsData) -> { flagsData.put("zip_input", true); flagsData.put("zip", true); },
				/*-s  */ (flag, arguments, index, flagsData) -> { flagsData.put("show_after_processing", true); }
		);
		
		return fp;
	}
}
